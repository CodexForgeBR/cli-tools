#!/bin/bash

# git wrapper script - Blocks destructive commands when called from automated CLIs
# Created for CodexForge CLI Tools
# Repository: https://github.com/CodexForgeBR/cli-tools

DEBUG_LOG="$HOME/.git-wrapper-debug.log"

# Function to check entire process ancestry for automated CLI tools
check_process_tree() {
    local pid=$1
    local depth=0
    local max_depth=20

    echo "[$(date)] Starting process tree check from PID=$pid" >> "$DEBUG_LOG"

    while [[ $pid -gt 1 ]] && [[ $depth -lt $max_depth ]]; do
        local cmd=$(ps -o comm= -p $pid 2>/dev/null)
        local cmdline=$(ps -o args= -p $pid 2>/dev/null)

        echo "  Depth $depth: PID=$pid, cmd='$cmd'" >> "$DEBUG_LOG"

        # Check for Claude Code, Codex CLI, Gemini CLI markers
        if [[ "$cmd" =~ (claude|codex|gemini|node|python) ]] || \
           [[ "$cmdline" =~ (claude-code|codex-cli|gemini-cli|@anthropics/claude|/codex|/gemini) ]]; then
            echo "  MATCHED! Detected: $cmd" >> "$DEBUG_LOG"
            echo "$cmd"
            return 0
        fi

        # Move to parent process
        pid=$(ps -o ppid= -p $pid 2>/dev/null | tr -d ' ')
        ((depth++))
    done

    echo "  No match found in process tree" >> "$DEBUG_LOG"
    return 1
}

# Function to check if command is destructive
is_destructive_command() {
    local subcommand=""
    local skip_next=0
    local args=("$@")

    # Find the git subcommand (first non-flag argument after "git")
    for i in "${!args[@]}"; do
        local arg="${args[$i]}"

        # Skip "git" itself
        [[ "$arg" == "git" ]] && continue

        # Skip flag values (for flags that take arguments)
        if [[ $skip_next -eq 1 ]]; then
            skip_next=0
            continue
        fi

        # Skip flags, but mark if next arg should be skipped
        if [[ "$arg" == -* ]]; then
            # Flags that take a value: -m, -C, -c, -F, -S
            if [[ "$arg" =~ ^-(m|C|c|F|S)$ ]]; then
                skip_next=1
            fi
            continue
        fi

        # First positional argument is the subcommand
        subcommand="$arg"
        break
    done

    # Now check based on subcommand
    case "$subcommand" in
        commit)
            # Check for --no-verify or -n (but not in combination with -m value)
            for i in "${!args[@]}"; do
                local arg="${args[$i]}"
                [[ "$arg" == "--no-verify" ]] && {
                    echo "BLOCKED: git commit --no-verify bypasses pre-commit hooks (Husky.Net validation)"
                    return 0
                }
                # -n alone (not part of -nm or followed by message)
                [[ "$arg" == "-n" ]] && {
                    echo "BLOCKED: git commit -n bypasses pre-commit hooks (Husky.Net validation)"
                    return 0
                }
            done
            ;;
        reset)
            for arg in "${args[@]}"; do
                [[ "$arg" == "--hard" ]] && {
                    echo "BLOCKED: git reset --hard destroys uncommitted changes permanently"
                    return 0
                }
            done
            ;;
        clean)
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-[fdxFDX]+$ ]] || [[ "$arg" == "--force" ]]; then
                    echo "BLOCKED: git clean -f/-d/-x deletes untracked/ignored files permanently"
                    return 0
                fi
            done
            ;;
        push)
            for arg in "${args[@]}"; do
                [[ "$arg" == "--force" || "$arg" == "-f" ]] && {
                    echo "BLOCKED: git push --force rewrites remote history (dangerous on shared branches)"
                    return 0
                }
                [[ "$arg" == "--force-with-lease" ]] && {
                    echo "BLOCKED: git push --force-with-lease still rewrites remote history"
                    return 0
                }
            done
            ;;
    esac

    # Not destructive
    return 1
}

# Main logic
detected_cli=""
if detected_cli=$(check_process_tree $$); then
    # We're in an automated CLI context - check for destructive commands
    echo "[$(date)] Detected automated CLI: $detected_cli" >> "$DEBUG_LOG"
    echo "[$(date)] Command: git $*" >> "$DEBUG_LOG"

    # Check if this is a destructive operation
    if error_msg=$(is_destructive_command "git $*"); then
        echo "" >&2
        echo "========================================" >&2
        echo "GIT WRAPPER: DESTRUCTIVE COMMAND BLOCKED" >&2
        echo "========================================" >&2
        echo "" >&2
        echo "$error_msg" >&2
        echo "" >&2
        echo "Detected automated CLI tool: $detected_cli" >&2
        echo "" >&2
        echo "This protection prevents Claude Code and other automated tools" >&2
        echo "from running destructive git commands that could:" >&2
        echo "  - Bypass security hooks (pre-commit validation)" >&2
        echo "  - Rewrite git history (force push)" >&2
        echo "  - Permanently delete uncommitted work (reset --hard, clean -f)" >&2
        echo "" >&2
        echo "To bypass this protection (if absolutely necessary):" >&2
        echo "  1. Run the command from your regular terminal (not from Claude)" >&2
        echo "  2. Or use the real git binary: /opt/homebrew/bin/git $*" >&2
        echo "" >&2
        echo "See ~/.git-wrapper-debug.log for details" >&2
        echo "========================================" >&2
        echo "" >&2

        echo "[$(date)] BLOCKED destructive command" >> "$DEBUG_LOG"
        exit 1
    fi

    echo "[$(date)] Command allowed (not destructive)" >> "$DEBUG_LOG"
fi

# Execute real git command (for safe commands or non-automated context)
# Prefer Homebrew git over system git
if [[ -x /opt/homebrew/bin/git ]]; then
    exec /opt/homebrew/bin/git "$@"
else
    exec /usr/bin/git "$@"
fi
